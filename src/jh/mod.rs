//!series expansion method for radial Teukolsky equation.
// mod lo_series;
// mod so_series;
mod local_solution;

use crate::const_value::I;
use crate::utilies::*;
use local_solution::*;
use num_complex::Complex;
use std::f64::consts::E;
use std::ops::Index;

#[inline]
fn do_mix(mix: &[NormC64; 2], v0: &NormResC64, v1: &NormResC64) -> NormResC64 {
    if v0.exp2 + mix[0].exp2 > v1.exp2 + mix[1].exp2 {
        let exp2 = v1.exp2 + mix[1].exp2 - v0.exp2 - mix[0].exp2;
        NormResC64 { exp2: v0.exp2 + mix[0].exp2, res: mix[0].v * v0.res + 2.0_f64.powi(exp2 as i32) * mix[1].v * v1.res }
    } else {
        let exp2 = v0.exp2 + mix[0].exp2 - v1.exp2 - mix[1].exp2;
        NormResC64 { exp2: v1.exp2 + mix[1].exp2, res: 2.0_f64.powi(exp2 as i32) * mix[0].v * v0.res + mix[1].v * v1.res }
    }
}
#[inline]
fn do_mix3(mix: &[NormC64; 2], v0: &ResN<3, Complex<f64>>, v1: &ResN<3, Complex<f64>>) -> ResN<3, Complex<f64>> {
    let mix = [mix[0].to_c64(), mix[1].to_c64()];
    ResN([mix[0] * v0[0] + mix[1] * v1[0], mix[0] * v0[1] + mix[1] * v1[1], mix[0] * v0[2] + mix[1] * v1[2]])
}
/// a series of ordinary point expansion
struct RVec {
    coe_vec: Vec<Complex<f64>>,
    ord_vec: Vec<Ordinary>,
}
impl Default for RVec {
    #[inline]
    fn default() -> Self {
        RVec { coe_vec: Vec::with_capacity(1024), ord_vec: Vec::with_capacity(32) }
    }
}
impl Index<usize> for RVec {
    type Output = Ordinary;
    #[inline]
    fn index(&self, index: usize) -> &Self::Output {
        unsafe { self.ord_vec.get_unchecked(index) }
    }
}
impl HeapSize for RVec {
    fn get_heapsize(&self) -> usize {
        self.coe_vec.get_heapsize() + self.ord_vec.get_heapsize()
    }
}
///generate a solution with a large effective range, or calculate it at some given point.
impl RVec {
    #[inline]
    fn len(&self) -> usize {
        self.ord_vec.len()
    }
    #[inline]
    fn last_cal(&self, x: f64) -> NormResC64 {
        unsafe { self.ord_vec.last().unwrap_unchecked().cal(&self.coe_vec, x) }
    }

    ///generate a solution with a large effective range, from ```x``` to ```target``` and ```x>target```
    fn gen_left(target: f64, p: &Para<f64>, x: f64, v: NormResC64, num: usize, err: f64) -> Self {
        debug_assert!(target < x);
        let mut rvec = Self::default();
        // let mut rvec = Vec::with_capacity(32);
        let ord_cache = p.ord_cache();
        let ord = Ordinary::new_x0(p, x, &mut rvec.coe_vec, &ord_cache, v, num, err);
        let mut x = ord.left();
        let mut v = ord.cal(&rvec.coe_vec, x);
        v.normalize();
        rvec.ord_vec.push(ord);
        loop {
            // let n=rvec.coe_vec.len();
            let ord = Ordinary::new_x0(p, x, &mut rvec.coe_vec, &ord_cache, v, num, err);
            x = ord.left();
            if target > x {
                rvec.ord_vec.push(ord);
                break;
            }
            v = ord.cal(&rvec.coe_vec, x);
            v.normalize();
            rvec.ord_vec.push(ord);
        }
        rvec
    }
    ///generate a solution with a large effective range, from ```x``` to ```target``` and ```x<target```
    fn gen_right(target: f64, p: &Para<f64>, x: f64, v: NormResC64, num: usize, err: f64) -> Self {
        debug_assert!(target > x);
        let mut rvec = Self::default();
        // let mut rvec = Vec::with_capacity(32);
        let ord_cache = p.ord_cache();
        let ord = Ordinary::new_x0(p, x, &mut rvec.coe_vec, &ord_cache, v, num, err);
        let mut x = ord.right();
        let mut v = ord.cal(&rvec.coe_vec, x);
        v.normalize();
        rvec.ord_vec.push(ord);
        loop {
            let ord = Ordinary::new_x0(p, x, &mut rvec.coe_vec, &ord_cache, v, num, err);
            x = ord.right();
            if target < x {
                rvec.ord_vec.push(ord);
                break;
            }
            v = ord.cal(&rvec.coe_vec, x);
            v.normalize();
            rvec.ord_vec.push(ord);
        }
        rvec
    }
    ///calculate a solution generated by ```gen_left```, if ```x<zero.left()```, the result is the value of ```self``` at ```x``` , otherwise, the result is ```zero``` at ```x```
    ///
    /// if ```x``` out of the effective range of ```self``` and ```zero```, it will cause a UB in release mode, and never exit or panic in debug mode.
    #[inline]
    fn cal_left(&self, x: f64) -> NormResC64 {
        debug_assert!(x < self[0].x0 && x > self.ord_vec.last().unwrap().left());
        let mut upper_n = self.len();
        let mut half_n: usize = upper_n / 2;
        let mut lower_n = 0;
        loop {
            if x > self[half_n].x0 {
                upper_n = half_n;
                half_n = (upper_n - lower_n) / 2 + lower_n;
            } else if x < self[half_n].left() {
                lower_n = half_n;
                half_n = (upper_n - lower_n) / 2 + lower_n;
            } else {
                debug_assert!(x <= self[half_n].x0 && x >= self[half_n].left());
                return self[half_n].cal(&self.coe_vec, x);
            }
        }
    }
    ///calculate a solution generated by ```gen_left```, if ```x>inf.right()```, the result is the value of ```self``` at ```x``` , otherwise, the result is ```inf``` at ```x```
    ///
    /// if ```x``` out of the effective range of ```self``` and ```inf```, it will cause a UB in release mode, and never exit or panic in debug mode.
    #[inline]
    fn cal_right(&self, x: f64) -> NormResC64 {
        debug_assert!(x > self[0].x0 && x < self.ord_vec.last().unwrap().right());
        let mut upper_n = self.len();
        let mut half_n: usize = upper_n / 2;
        let mut lower_n = 0;
        loop {
            if x < self[half_n].x0 {
                upper_n = half_n;
                half_n = (upper_n - lower_n) / 2 + lower_n;
            } else if x > self[half_n].right() {
                lower_n = half_n;
                half_n = (upper_n - lower_n) / 2 + lower_n;
            } else {
                debug_assert!(x >= self[half_n].x0 || x <= self[half_n].right());
                return self[half_n].cal(&self.coe_vec, x);
            }
        }
    }

    fn cal_left3(&self, x: f64) -> ResN<3, Complex<f64>> {
        let mut upper_n = self.len();
        let mut half_n: usize = upper_n / 2;
        let mut lower_n = 0;
        loop {
            if x > self[half_n].x0 {
                upper_n = half_n;
                half_n = (upper_n - lower_n) / 2 + lower_n;
            } else if x < self[half_n].left() {
                lower_n = half_n;
                half_n = (upper_n - lower_n) / 2 + lower_n;
            } else {
                debug_assert!(x <= self[half_n].x0 && x >= self[half_n].left());
                return self[half_n].cal3(&self.coe_vec, x);
            }
        }
    }

    fn cal_right3(&self, x: f64) -> ResN<3, Complex<f64>> {
        let mut upper_n = self.len();
        let mut half_n: usize = upper_n / 2;
        let mut lower_n = 0;
        loop {
            if x < self[half_n].x0 {
                upper_n = half_n;
                half_n = (upper_n - lower_n) / 2 + lower_n;
            } else if x > self[half_n].right() {
                lower_n = half_n;
                half_n = (upper_n - lower_n) / 2 + lower_n;
            } else {
                debug_assert!(x >= self[half_n].x0 || x <= self[half_n].right());
                return self[half_n].cal3(&self.coe_vec, x);
            }
        }
    }
}
struct  InfSolution {
    ii:InfinityIn,
    io:InfinityOut
}
impl HeapSize for InfSolution {
    fn get_heapsize(&self) -> usize {
        self.ii.get_heapsize() + self.io.get_heapsize()
    }
}
impl InfSolution {
    #[inline]
    fn cal_i(&self, p: &Para<f64>, x: f64) -> NormResC64 {
        self.ii.cal(p, x)
    }
    fn cal_i3(&self, p: &Para<f64>, x: f64) -> ResN<3, Complex<f64>> {
        self.ii.cal3(p, x)
    }
    #[inline]
    fn cal_o(&self, p: &Para<f64>, x: f64) -> NormResC64 {
        self.io.cal(p, x)
    }
    fn cal_o3(&self, p: &Para<f64>, x: f64) -> ResN<3, Complex<f64>> {
        self.io.cal3(p, x)
    }
}
struct ZeroSolution {
    zi: ZeroIn,
    zo: ZeroOut,
}
impl HeapSize for ZeroSolution {
    fn get_heapsize(&self) -> usize {
        self.zi.get_heapsize() + self.zo.get_heapsize()
    }
}
impl ZeroSolution {
    #[inline]
    fn cal_i(&self, p: &Para<f64>, x: f64) -> NormResC64 {
        self.zi.cal(p, x)
    }
    fn cal_i3(&self, p: &Para<f64>, x: f64) -> ResN<3, Complex<f64>> {
        self.zi.cal3(p, x)
    }
    #[inline]
    fn cal_o(&self, p: &Para<f64>, x: f64) -> NormResC64 {
        self.zo.cal(p, x)
    }
    fn cal_o3(&self, p: &Para<f64>, x: f64) -> ResN<3, Complex<f64>> {
        self.zo.cal3(p, x)
    }
}
///radial Teukolsky function by se method
#[repr(C)]
pub struct SE<T> {
    pub p: Para<T>,
    pub rp: f64,

    zi_left: f64,
    zo_left: f64,
    zs: ZeroSolution,

    ii_right: f64,
    io_right: f64,
    is: InfSolution,

    zir: RVec,
    ior: RVec,

    mix_ii_io_zi: [NormC64; 2],
    mix_zi_zo_io: [NormC64; 2],

    asy_c: [NormC64; 4],
}
impl HeapSize for SE<f64> {
    fn get_heapsize(&self) -> usize {
        self.zs.get_heapsize() + self.is.get_heapsize() + self.zir.get_heapsize() + self.ior.get_heapsize()
    }
}
impl SE<f64> {
    #[inline]
    fn int_fx(p: &Para<f64>, x: f64) -> NormC64 {
        let v_ln = 2.0 * (p.epsilon * I) * p.kappa * x + (1.0 - p.epsilon * I - p.s - p.tau * I) * (-x).ln() + (1.0 + p.epsilon * I + p.s - p.tau * I) * (1.0 - x).ln();

        NormC64::from_apowb(E, v_ln)
    }
    #[inline]
    fn inner(v1: NormResC64, v2: NormResC64, ix: NormC64) -> NormC64 {
        NormC64 { exp2: v1.exp2 + v2.exp2 + ix.exp2, v: (v1.res.1 * v2.res.0 - v2.res.1 * v1.res.0) * ix.v }
    }
    pub fn new_raw(s: f64, _l: f64, m: f64, a: f64, omega: f64, lambda: f64, num_z: usize, num_i: usize, num_r: usize, err: f64) -> Self {
        let err=err/10.;//need a accuracy compensation. Because i relaxed the precision requirement in part of the subsequent process. For example, see [`InfinityOut::check`]
        let s2 = 2. * s;
        if s2.fract() > 1e-10 {
            panic!("s should be integer or half integer")
        }
        let extra_term = lambda.abs().sqrt().floor() as usize;
        let p = Para::new(s, m, a, omega, lambda);

        let is;

        let ii_right;
        let io_right;
        let ii_edge_value;
        let io_edge_value;
        let ii = InfinityIn::new(&p, num_i + 2 * extra_term, err);
        let io = InfinityOut::new(&p, num_i + 2 * extra_term, err);
        io_right = io.right();
        ii_right = ii.right();
        ii_edge_value = ii.cal(&p, ii_right);
        io_edge_value = io.cal(&p, io_right);
        is = InfSolution{ii, io};


        let ek = p.epsilon * p.kappa;

        let zi = ZeroIn::new(&p, num_z + 2 * extra_term, err);
        let zo = ZeroOut::new(&p, num_z + 2 * extra_term, err);
        let zi_left = zi.left();
        let zo_left = zo.left();
        let zi_edge_value = zi.cal(&p, zi_left);
        let zo_edge_value = zo.cal(&p, zo_left);
        let zs: ZeroSolution = ZeroSolution { zi, zo };

        let zir = RVec::gen_left(ii_right, &p, zi_left, zi_edge_value.clone(), num_r + extra_term, err);
        let ior = RVec::gen_right(zo_left, &p, io_right, io_edge_value.clone(), num_r + extra_term, err);

        let zi_ii_right_value = zir.last_cal(ii_right);
        let io_ii_right_value = if ii_right <= io_right { is.cal_o(&p, ii_right) } else { ior.cal_right(ii_right) };
        let io_zo_left_value = ior.last_cal(zo_left);
        let zi_zo_left_value = if zo_left >= zi_left { zs.cal_i(&p, zo_left) } else { zir.cal_left(zo_left) };
        let ix = Self::int_fx(&p, ii_right);
        let zimix_ii = Self::inner(zi_ii_right_value.clone(), ii_edge_value, ix) / (ek / I) / 2.0;
        let zimix_io = Self::inner(zi_ii_right_value, io_ii_right_value, ix) / (ek * I) / 2.0;

        let ix = Self::int_fx(&p, zo_left);
        let ibmix_zi = Self::inner(io_zo_left_value.clone(), zo_edge_value, ix) / I / (p.epsilon + p.tau - I * s);
        let ibmix_zo = Self::inner(io_zo_left_value, zi_zo_left_value, ix) * I / (p.epsilon + p.tau - I * s);

        let mix_ii_io_zi = [zimix_io, zimix_ii];
        let mix_zi_zo_io = [ibmix_zi, ibmix_zo];

        let rp = 1.0 + (1.0 - a * a).sqrt();

        let kappa2 = 1.0 - a.powi(2);
        let ip = (omega - m * a / rp / 2.) * I;
        let io = omega * I;
        let s2 = s2 as i32;
        let zic = NormC64::from_apowb(kappa2, ip + s) * 2.0_f64.powi(s2) * NormC64::from_expfx(ip * rp);
        let zoc = NormC64::from_apowb(kappa2, -ip) * NormC64::from_expfx(-ip * rp);
        let iic = NormC64::from_apowb(kappa2, io + 0.5) * 2.0 * NormC64::from_expfx(io * rp);
        let ioc = NormC64::from_apowb(kappa2, -io + s + 0.5) * 2.0_f64.powi(1 + s2) * NormC64::from_expfx(-io * rp);
        let asy_c = [zic, zoc, iic, ioc];

        SE { p, rp, zi_left, zo_left, zs, ii_right, io_right, is, zir, ior, mix_ii_io_zi, mix_zi_zo_io, asy_c }
    }
    pub fn new(s: f64, l: f64, m: f64, a: f64, omega: f64, lambda: f64) -> Self {
        const NUM_Z: usize = 20;
        const NUM_I: usize = 20;
        const NUM_R: usize = 30;
        const ERR: f64 = 1e-15;
        Self::new_raw(s, l, m, a, omega, lambda, NUM_Z, NUM_I, NUM_R, ERR)
    }
    #[inline]
    fn head(&self, x: f64) -> NormResC64 {
        let fx = self.p.epsilon * self.p.kappa * x * I - (self.p.s + (self.p.epsilon + self.p.tau) * I / 2.0) * (-x).ln() + (self.p.epsilon - self.p.tau) * I * (1.0 - x).ln() / 2.0;

        let dexp_fx_div_fx = (I * (self.p.epsilon * self.p.kappa * x * 2.0 * (-1.0 + x) - self.p.tau * 2.0 * x + self.p.epsilon + self.p.tau + 2.0 * I * self.p.s * (-1.0 + x))) / (2.0 * x * (-1.0 + x));

        NormResC64::from_expfx(fx, dexp_fx_div_fx)
    }

    fn head3(&self, x: f64) -> ResN<3, Complex<f64>> {
        let fx = self.p.epsilon * self.p.kappa * x * I - (self.p.s + (self.p.epsilon + self.p.tau) * I / 2.0) * (-x).ln() + (self.p.epsilon - self.p.tau) * I * (1.0 - x).ln() / 2.0;
        let dfx = (I * (self.p.epsilon * self.p.kappa * x * 2.0 * (-1.0 + x) - self.p.tau * 2.0 * x + self.p.epsilon + self.p.tau + 2.0 * I * self.p.s * (-1.0 + x))) / (2.0 * x * (-1.0 + x));
        let ddfx = (self.p.s + (self.p.epsilon + self.p.tau) * I / 2.0) / x / x - (self.p.epsilon - self.p.tau) * I / 2.0 / (1.0 - x) / (1.0 - x);
        ResN::<3, Complex<f64>>::exp_fx(fx, dfx, ddfx)
    }
    #[inline]
    pub fn qp_cal(&self, r: f64) -> (NormResC64, NormResC64) {
        if r < self.rp {
            panic!("r should larger than r_+ = {}", self.rp)
        }
        let dcoe = -0.5 / self.p.kappa;
        let x = (r - self.rp) * dcoe;
        let h = self.head(x);

        let mut rup;
        let mut rin;
        if x < self.ii_right {
            rup = if x < self.io_right { self.is.cal_o(&self.p, x) } else { self.ior.cal_right(x) };
            let iiv = self.is.cal_i(&self.p, x);
            rin = do_mix(&self.mix_ii_io_zi, &iiv, &rup);
        } else if x < self.zo_left {
            rup = if x < self.io_right { self.is.cal_o(&self.p, x) } else { self.ior.cal_right(x) };
            rin = if x > self.zi_left { self.zs.cal_i(&self.p, x) } else { self.zir.cal_left(x) };
        } else {
            rin = if x > self.zi_left { self.zs.cal_i(&self.p, x) } else { self.zir.cal_left(x) };
            let zov = self.zs.cal_o(&self.p, x);
            rup = do_mix(&self.mix_zi_zo_io, &rin, &zov);
        }
        rup *= &h;
        rup.res.1 *= dcoe;
        rin *= &h;
        rin.res.1 *= dcoe;

        (rin, rup)
    }
    #[inline]
    pub fn btrans_qp(&self) -> NormC64 {
        self.asy_c[0]
    }
    #[inline]
    pub fn bref_qp(&self) -> NormC64 {
        self.mix_ii_io_zi[1] * self.asy_c[3]
    }
    #[inline]
    pub fn binc_qp(&self) -> NormC64 {
        self.mix_ii_io_zi[0] * self.asy_c[2]
    }
    #[inline]
    pub fn ctrans_qp(&self) -> NormC64 {
        self.asy_c[3]
    }
    #[inline]
    pub fn cup_qp(&self) -> NormC64 {
        self.mix_zi_zo_io[1] * self.asy_c[1]
    }
    #[inline]
    pub fn cref_qp(&self) -> NormC64 {
        self.mix_zi_zo_io[0] * self.asy_c[0]
    }

    pub fn cal(&self, r: f64) -> (Res<Complex<f64>>, Res<Complex<f64>>) {
        let (rin, rup) = self.qp_cal(r);
        (rin.to_res(), rup.to_res())
    }

    #[inline]
    pub fn btrans(&self) -> Complex<f64> {
        self.btrans_qp().to_c64()
    }
    #[inline]
    pub fn bref(&self) -> Complex<f64> {
        self.bref_qp().to_c64()
    }
    #[inline]
    pub fn binc(&self) -> Complex<f64> {
        self.binc_qp().to_c64()
    }
    #[inline]
    pub fn ctrans(&self) -> Complex<f64> {
        self.ctrans_qp().to_c64()
    }
    #[inline]
    pub fn cup(&self) -> Complex<f64> {
        self.cup_qp().to_c64()
    }
    #[inline]
    pub fn cref(&self) -> Complex<f64> {
        self.cref_qp().to_c64()
    }
    pub fn cal3_at(&self, r: f64) -> (ResN<3, Complex<f64>>, ResN<3, Complex<f64>>) {
        if r < self.rp {
            panic!("r should larger than r_+ = {}", self.rp)
        }
        let dcoe = -0.5 / self.p.kappa;
        let x = (r - self.rp) * dcoe;
        let h = self.head3(x);

        let mut rup;
        let mut rin;
        if x < self.ii_right {
            rup = if x < self.io_right { self.is.cal_o3(&self.p, x) } else { self.ior.cal_right3(x) };
            let iiv = self.is.cal_i3(&self.p, x);
            rin = do_mix3(&self.mix_ii_io_zi, &iiv, &rup);
        } else if x < self.zo_left {
            rup = if x < self.io_right { self.is.cal_o3(&self.p, x) } else { self.ior.cal_right3(x) };
            rin = if x > self.zi_left { self.zs.cal_i3(&self.p, x) } else { self.zir.cal_left3(x) };
        } else {
            rin = if x > self.zi_left { self.zs.cal_i3(&self.p, x) } else { self.zir.cal_left3(x) };
            let zov = self.zs.cal_o3(&self.p, x);
            rup = do_mix3(&self.mix_zi_zo_io, &rin, &zov);
        }
        rup *= &h;
        rup[1] *= dcoe;
        rup[2] *= dcoe * dcoe;
        rin *= &h;
        rin[1] *= dcoe;
        rin[2] *= dcoe * dcoe;

        (rin, rup)
    }
}

#[test]
fn result_check() {
    let ra = SE::new(-2.0, 2.0, 2.0, 0.9, 0.6, 0.4682269132106451);

    let resa = ra.cal(50.0);
    let resb = ra.cal(60.0);

    assert!((resa.0.0 / resb.0.0 - (0.5772632901629227 + 0.03698538818494014 * I)).abs() < 1e-10);
    assert!((resa.0.1 / resb.0.1 - (0.5822959333608482 + 0.028297162513521584 * I)).abs() < 1e-10);
    assert!((resa.1.0 / resb.1.0 - (0.5772633028124957 + 0.036985109743537845 * I)).abs() < 1e-10);
    assert!((resa.1.1 / resb.1.1 - (0.5822959036174361 + 0.028297440376956074 * I)).abs() < 1e-10);

    let resa = ra.cal(30.0);
    let resb = ra.cal(40.0);

    assert!((resa.0.0 / resb.0.0 - (0.4203006571112858 - 0.026376569477548014 * I)).abs() < 1e-10);
    assert!((resa.0.1 / resb.0.1 - (0.42786660893130724 - 0.0426789614233752 * I)).abs() < 1e-10);
    assert!((resa.1.0 / resb.1.0 - (0.4203011095501579 - 0.02637846297656461 * I)).abs() < 1e-10);
    assert!((resa.1.1 / resb.1.1 - (0.42786598334374926 - 0.04267708434536813 * I)).abs() < 1e-10);

    let resa = ra.cal(5.0);
    let resb = ra.cal(10.0);

    assert!((resa.0.0 / resb.0.0 - (-0.08829866697392612 + 0.06770435902336984 * I)).abs() < 1e-10);
    assert!((resa.0.1 / resb.0.1 - (-0.08962891590818914 + 0.11914712052468773 * I)).abs() < 1e-10);
    assert!((resa.1.0 / resb.1.0 - (-0.08853007031380666 + 0.0671258352796836 * I)).abs() < 1e-10);
    assert!((resa.1.1 / resb.1.1 - (-0.08958567297931715 + 0.11986515276629021 * I)).abs() < 1e-10);

    let resa = ra.cal(1.89);
    let resb = ra.cal(1.9);

    assert!((resa.0.0 / resb.0.0 - (0.9512680383568227 - 0.010324924793565641 * I)).abs() < 1e-10);
    assert!((resa.0.1 / resb.0.1 - (0.9703745184595597 - 0.013130597565983526 * I)).abs() < 1e-10);
    assert!((resa.1.0 / resb.1.0 - (0.9631014803646342 + 0.02256848446982569 * I)).abs() < 1e-10);
    assert!((resa.1.1 / resb.1.1 - (0.9812133762475541 - 0.01153990252936491 * I)).abs() < 1e-10);

    let resa = ra.cal(1.5);
    let resb = ra.cal(1.6);

    assert!((resa.0.0 / resb.0.0 - (0.13576357214363774 - 0.02698620605374016 * I)).abs() < 1e-10);
    assert!((resa.0.1 / resb.0.1 - (0.3294904054344203 - 0.08049838190317438 * I)).abs() < 1e-10);
    assert!((resa.1.0 / resb.1.0 - (1.066308897658316 + 0.41145281508500403 * I)).abs() < 1e-10);
    assert!((resa.1.1 / resb.1.1 - (1.1171284796305514 + 0.4113789468500662 * I)).abs() < 1e-10);

    assert!((ra.binc() / ra.btrans() - (0.9953800557040251 - 1.2518067341250638 * I)).abs() < 1e-6);
    assert!((ra.bref() / ra.btrans() - (0.11437098030548824 - 0.22674794826099218 * I)).abs() < 1e-6);
    assert!((ra.cup() / ra.ctrans() - (-0.9148830572855884 - 0.6043316678231366 * I)).abs() < 1e-6);
    assert!((ra.cref() / ra.ctrans() - (32.32567154069175 + 64.08775792207292 * I)).abs() < 1e-6);
}
